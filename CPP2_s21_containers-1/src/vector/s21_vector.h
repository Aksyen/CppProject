#ifndef VECTOR_H
#define VECTOR_H

#include <initializer_list>
#include <iostream>
#include <limits>

namespace s21 {
template <class T>
class vector {
 public:
  // определяет тип элемента (T — параметр шаблона)
  using value_type = T;
  // определяет тип ссылки на элемент
  using reference = T &;
  // определяет тип константной ссылки
  using const_reference = const T &;
  // определяет тип для итерации по контейнеру
  using iterator = T *;
  //  определяет тип константы для итерации по контейнеру
  using const_iterator = const T *;
  //  определяет тип размера контейнера, стандартный тип — size_t
  using size_type = size_t;

  ///////////////////////////////////////////////////////////////////////////////

  //	конструктор по умолчанию, создает пустой вектор
  vector();
  // параметризованный конструктор, создает вектор размера n
  vector(size_type n);
  //  Конструктор списка инициализаторов, создает вектор, инициализированный с
  //  помощью std::initializer_list
  vector(std::initializer_list<value_type> const &items);
  //	конструктор копий
  vector(const vector &v);
  //	конструктор перемещения
  vector(vector &&v);
  //  Перегрузка оператора присваивания для перемещения объекта
  vector<T> &operator=(vector &&v);
  //	деструктор
  ~vector();

  ///////////////////////////////////////////////////////////////////////////////

  //	доступ к указанному элементу с проверкой границ
  reference at(size_type pos);
  //	доступ к указанному элементу
  reference operator[](size_type pos);
  //	доступ к первому элементу
  const_reference front();
  //	доступ к последнему элементу
  const_reference back();
  //	прямой доступ к базовому массиву
  iterator data();

  //////////////////////////////////////////////////////////////////////////////

  //	возвращает итератор на начало
  iterator begin();
  //	возвращает итератор на конец
  iterator end();

  //////////////////////////////////////////////////////////////////////////////

  //	проверяет, пуст ли контейнер
  bool empty();
  //	возвращает количество элементов
  size_type size();
  //	возвращает максимально возможное количество элементов
  size_type max_size();
  //	выделяет хранилище размером с элементы и копирует текущие элементы
  // массива в новый выделенный массив
  void reserve(size_type size);
  //	возвращает количество элементов, которые могут храниться в выделенной в
  // данный момент памяти
  size_type capacity();
  //	уменьшает использование памяти за счет освобождения неиспользуемой
  // памяти
  void shrink_to_fit();

  /////////////////////////////////////////////////////////////////////////////////

  //	очищает содержимое
  void clear();
  //	вставляет элемент в конкретную позицию и возвращает итератор,
  // указывающий на новый элемент
  iterator insert(iterator pos, const_reference value);
  //	стирает элемент в позиции pos
  void erase(iterator pos);
  //	добавляет элемент в конец
  void push_back(const_reference value);
  //	удаляет последний элемент
  void pop_back();
  //	меняет местами содержимое
  void swap(vector &other);

  ////////////////////////////////////////////////////////////////////////////////

  //	вставляет все переданные элементы, начиная с указаной позиции и
  // возвращает итератор, указывающий на новый элемент
  template <typename... Args>
  iterator insert_many(const_iterator pos, Args &&...args);

  //	вставляет все переданные элементы в конец и
  // возвращает итератор, указывающий на новый элемент
  template <typename... Args>
  void insert_many_back(Args &&...args);

  ////////////////////////////////////////////////////////////////////////////////

  // служит для итерации по массиву
  iterator iter;

 private:
  value_type *arr_;
  size_type size_;
  size_type capacity_;
};
};  // namespace s21

#include "s21_vector.tpp"

#endif